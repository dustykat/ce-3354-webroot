{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# DTRM Survival Model\n",
    "\n",
    "# Parcel speeds using a Manning's type model\n",
    "#   V = (1.5/N)*R**(2/3)*S**(1/2)\n",
    "\n",
    "\n",
    "#       INCREASES DOWNWARD, X INCREASES RIGHTWARD\n",
    "#\n",
    "#     XP(),YP()    ARE X AND Y COORDINATES OF PARTICLES\n",
    "#     XG(),YG()    ARE X AND Y COORDINATES OF GRID\n",
    "#  HEAD()       IS HEAD DISTRIBUTION DEFINED ON THE GRID\n",
    "#  VX()         IS COMPUTED VELOCITY IN DIRECTION OF FLOW\n",
    "#  VY()         IS COMPUTED TIME OF TRAVEL TO NEXT CELL IN DIRECTION OF FLOW\n",
    "#  DMAP()       IS FLOW DIRECTION ARRAY IN 8-DIRECTIONS; \n",
    "#                 DIRECTION 0 IS OUTLET\n",
    "#                 DIRECTION 9 IS A PIT\n",
    "#                 DIRECTION -1 IS NO-FLOW CELL\n",
    "#                 ENTIRE MODEL IS SURROUNDED BY DIRECTION 0 CELLS, THESE ARE IGNORED\n",
    "#\n",
    "#                \n",
    "#  DELATX       IS GRID SPACING\n",
    "#  DELTAT       IS TIME INCREMENT\n",
    "#  NP           ARE NUMBER OF PARTICLES\n",
    "#\n",
    "#  Y - COORDINATE OF GRID IS ASSOCIATED WITH THE \"ROW\" INDEX\n",
    "#  X - COORDINATE OF GRID IS ASSOCIATED WITH THE \"COLUMN\" INDEX\n",
    "#\n",
    "#  Y - INCREASES DOWNWARD\n",
    "#  X - INCREASES RIGHTWARD\n",
    "#\n",
    "#  THE UPPER LEFT HAND CORNER OF THE HEAD ARRAY IS X=0,Y=0\n",
    "#  THE LOWER RIGHT HAND CORNER OF THE HEAD ARRAY IS X=XMAX,Y=YMAX\n",
    "#\n",
    "# DECLARE ARRAYS\n",
    "\n",
    "\n",
    "###########################################################\n",
    "#### import memory management tools (garbage collector) ###\n",
    "###########################################################\n",
    "import gc\n",
    "gc.collect();\n",
    "###########################################################\n",
    "#### import plotting support packages                  ####\n",
    "###########################################################\n",
    "import matplotlib.pyplot as plt\n",
    "###########################################################\n",
    "#### import random number generator for particle death ####\n",
    "###########################################################\n",
    "import random \n",
    "\n",
    "def mappart(plotfileout,title,xpos,ypos,xsink,ysink):\n",
    "    import matplotlib.pyplot as plt\n",
    "# build a plot of particle positions and outlet position\n",
    "    plt.figure()\n",
    "    plt.title(title)\n",
    "    plt.scatter(xpos, ypos, s=1, color='blue')\n",
    "    plt.scatter(xsink, ysink, s=100, color='magenta')\n",
    "    plt.savefig(plotfileout);\n",
    "    return\n",
    "\n",
    "####################################\n",
    "#### Specify the input file name ###\n",
    "####################################\n",
    "filename = \"sta08055700.mat.dat\" # dtrm input file\n",
    "\n",
    "#################################\n",
    "#### Read the DTRM input file ###\n",
    "#################################\n",
    "afile = open(filename,\"r\")  # connect to the file\n",
    "amatrix = [] # null object to store read\n",
    "bmatrix = []\n",
    "rowNumA = 0\n",
    "rowNumB = 0\n",
    "aflag = 1\n",
    "bflag = 1\n",
    "verbose = 1\n",
    "substrings_to_check = [\"DIRECTIVE\",\"VERBOSE\",\"TERSE\",\"DMAP\",\"SMAP\",\"TMAP\"]\n",
    "for line in afile:\n",
    "# if line contains substrings then first line\n",
    "    if any(substring in line for substring in substrings_to_check):\n",
    "#    if \"DIRECTIVE\" in line:      \n",
    "        directive = line.strip().split()[0]\n",
    "#        print('Row : ',rowNumA,'Contents : ',line)\n",
    "        rowNumA += 1\n",
    "        continue\n",
    "    if rowNumA == 1:  # this is second line\n",
    "        nrow = line.strip().split()[0]\n",
    "        ncol = line.strip().split()[1]\n",
    "#        print(nrow,ncol)\n",
    "#        print('Row : ',rowNumA,'Contents : ',line.strip().split())\n",
    "        aflag = 0 # read into amatrix\n",
    "        rowNumA += 1\n",
    "        continue\n",
    "####################################\n",
    "#### Check for seperator fields ####\n",
    "#### Read input matrices to EOL ####\n",
    "####################################\n",
    "    if \"CMAN,FDEEP,NMAN\" in line: # seperates \n",
    "        cman  = line.strip().split()[0]\n",
    "        fdeep = line.strip().split()[1]\n",
    "        nman  = line.strip().split()[2]\n",
    "        alife = line.strip().split()[3]\n",
    "#        print('Row : ',rowNumA,'Contents : ',line)\n",
    "#        rowNumA += 1\n",
    "        aflag = 1\n",
    "        bflag = 1\n",
    "        continue\n",
    "    if \"DX,DT,TMAX,D1\" in line: # seperates \n",
    "        dx   = line.strip().split()[0]\n",
    "        dt   = line.strip().split()[1]\n",
    "        tmax = line.strip().split()[2]\n",
    "        d1   = line.strip().split()[3]\n",
    "        dyt  = line.strip().split()[4]\n",
    "        dxt  = line.strip().split()[5]\n",
    "#        print('Row : ',rowNumA,'Contents : ',line)\n",
    "#        rowNumA += 1\n",
    "        aflag = 1\n",
    "        bflag = 1\n",
    "        continue\n",
    "    if \"NP,PRINT_N\" in line: # seperates \n",
    "        np   = line.strip().split()[0]\n",
    "        npt   = line.strip().split()[1]\n",
    "#        print('Row : ',rowNumA,'Contents : ',line)\n",
    "        aflag = 1\n",
    "        bflag = 0 # read into bmatrix \n",
    "        continue\n",
    "    if \"outlet loc\" in line: # seperates \n",
    "        nrout   = line.strip().split()[0]\n",
    "        ncout   = line.strip().split()[1]\n",
    "        elevout = line.strip().split()[2]\n",
    "#########################################\n",
    "#### reindex to start from 0 index   ####\n",
    "#########################################\n",
    "        nrout = int(nrout) - 1\n",
    "        ncout = int(ncout) - 1\n",
    "#        print('Row : ',rowNumA,'Contents : ',line)\n",
    "        aflag = 1\n",
    "        bflag = 1\n",
    "    elif aflag == 0:\n",
    "        amatrix.append([float(n) for n in line.strip().split()])\n",
    "#        print('Row : ',rowNumA,'Contents : ',line.strip().split())\n",
    "        rowNumA += 1\n",
    "    elif bflag == 0:\n",
    "        bmatrix.append([float(n) for n in line.strip().split()])\n",
    "#        print('Row : ',rowNumB,'Contents : ',line.strip().split())\n",
    "        rowNumB += 1\n",
    "#    print(\"loop bottom\")\n",
    "afile.close() # Disconnect the file\n",
    "#################################\n",
    "#### Echo to DTRM output file ###\n",
    "#################################\n",
    "fileout = filename.replace(\"mat\",\"out\")\n",
    "afile = open(fileout,\"w\")  # connect to the file\n",
    "afile.write(\"DTRM-Survival Jupyter/iPython\")\n",
    "afile.write(\"\\n  INPUT FILENAME : \" + repr(filename))\n",
    "afile.write(\"\\n OUTPUT FILENAME : \" + repr(fileout))\n",
    "afile.write(\"\\n  OUTPUT DENSITY : \" + directive)\n",
    "afile.write(\"\\n            ROWS : \" + repr(int(nrow)))\n",
    "afile.write(\"\\n         COLUMNS : \" + repr(int(ncol)))\n",
    "afile.write(\"\\n            CMAN : \" + repr(float(cman)))\n",
    "afile.write(\"\\n           FDEEP : \" + repr(float(fdeep)))\n",
    "afile.write(\"\\n            NMAN : \" + repr(float(nman)))\n",
    "afile.write(\"\\n           ALIFE : \" + repr(float(alife)))\n",
    "afile.write(\"\\n              DX : \" + repr(float(dx)))\n",
    "afile.write(\"\\n              DT : \" + repr(float(dt)))\n",
    "afile.write(\"\\n            TMAX : \" + repr(float(tmax)))\n",
    "afile.write(\"\\n              D1 : \" + repr(float(d1)))\n",
    "afile.write(\"\\n             DYT : \" + repr(float(dyt)))\n",
    "afile.write(\"\\n             DXT : \" + repr(float(dxt)))\n",
    "afile.write(\"\\n NUMBER PARTICLES: \" + repr(int(np)))\n",
    "afile.write(\"\\n PRINT FREQUENCY : \" + repr(int(npt)))\n",
    "afile.write(\"\\n      OUTLET ROW : \" + repr(int(nrout)))\n",
    "afile.write(\"\\n   OUTLET COLUMN : \" + repr(int(ncout)))\n",
    "afile.write(\"\\nOUTLET ELEVATION : \" + repr(float(elevout)))\n",
    "afile.close()\n",
    "##############################################\n",
    "#### structure the amatrix and bmatrix    ####\n",
    "#### arrays into index accessible arrays  ####\n",
    "##############################################\n",
    "ncol = int(ncol)\n",
    "nrow = int(nrow)\n",
    "#print(nrow,ncol)\n",
    "head = [[0.0 for j in range(ncol)] for i in range(nrow)]\n",
    "dmap = [[-999.0 for j in range(ncol)] for i in range(nrow)]\n",
    "pmap = [[0.0 for j in range(ncol)] for i in range(nrow)]\n",
    "pbmap = [[0.0 for j in range(ncol)] for i in range(nrow)]\n",
    "nr2r = len(amatrix)\n",
    "nc2r = len(amatrix[0])\n",
    "#print(nr2r,nc2r)\n",
    "col2assign = 0\n",
    "row2assign = 0\n",
    "for ir2r in range(nr2r): #i is row to assign\n",
    "    for jc2r in range(nc2r): #j is column to assign\n",
    "#        print(\"rc2r \",ir2r,jc2r,row2assign,col2assign)\n",
    "        head[row2assign][col2assign] = float(amatrix[ir2r][jc2r])\n",
    "        pmap[row2assign][col2assign] = float(bmatrix[ir2r][jc2r])\n",
    "        pbmap[row2assign][col2assign] = float(bmatrix[ir2r][jc2r])\n",
    "        col2assign += 1\n",
    "        if col2assign >= ncol:\n",
    "            col2assign = 0\n",
    "            row2assign += 1\n",
    "            break\n",
    "##############################################\n",
    "#### get min/max and mask count and report ###\n",
    "##############################################\n",
    "maxhead = 0.00000001\n",
    "minhead = 10000000.0\n",
    "countP = 0.0\n",
    "for irow in range(nrow):\n",
    "    if max(head[irow]) > maxhead:\n",
    "        maxhead = max(head[irow])\n",
    "    if min(head[irow]) < minhead:\n",
    "        minhead = min(head[irow])\n",
    "    countP = countP + sum(pbmap[irow])\n",
    "\n",
    "afile = open(fileout,\"a\")  # connect to the file; append\n",
    "afile.write(\"\\n   MIN ELEVATION : \" + repr(float(minhead)))\n",
    "afile.write(\"\\n   MAX ELEVATION : \" + repr(float(maxhead)))\n",
    "afile.write(\"\\n      MASK COUNT : \" + repr(int(countP)))\n",
    "afile.close()\n",
    "\n",
    "##############################################\n",
    "#### build grid locations for cell centers ###\n",
    "##############################################\n",
    "xg  = [0.0  for i in range(ncol)]\n",
    "yg  = [0.0  for i in range(nrow)]\n",
    "xbg = [0.0  for i in range(ncol)]\n",
    "ybg = [0.0  for i in range(nrow)]\n",
    "dx  = float(dx)\n",
    "\n",
    "yg[0]  =0.5*dx\n",
    "xg[0]  =0.5*dx\n",
    "ybg[0] =0.5*dx\n",
    "xbg[0] =0.5*dx\n",
    "for irow in range(1,nrow):\n",
    "    yg[irow]=yg[irow-1]+dx\n",
    "    ybg[irow]=ybg[irow-1]+dx\n",
    "for jcol in range(1,ncol):\n",
    "    xg[jcol]=xg[jcol-1]+dx\n",
    "    xbg[jcol]=xbg[jcol-1]+dx\n",
    "if directive == 'VERBOSE':\n",
    "    afile = open(fileout,\"a\")  # connect to the file; append\n",
    "    afile.write(\"\\n GRID CELL LOCATIONS : \\n ICELL XGRID YGRID \")\n",
    "    cellcount=1\n",
    "    for irow in range(nrow):\n",
    "        for jcol in range(ncol):\n",
    "            afile.write('\\n ' + repr(cellcount) + ' ' + repr(round(xg[jcol],3)) + ' ' + repr(round(yg[irow],3)))\n",
    "            cellcount += 1\n",
    "    afile.close()\n",
    "############ memory management ###############\n",
    "del amatrix    # release objects to free RAM #\n",
    "del bmatrix    # release objects to free RAM #\n",
    "gc.collect();  # force garbage collection    #\n",
    "##############################################\n",
    "\n",
    "##############################################\n",
    "#### locate the outlet in the grid system ####\n",
    "##############################################\n",
    "xout=xg[int(ncout)]\n",
    "yout=yg[int(nrout)]\n",
    "xmin=xg[0]\n",
    "ymin=yg[0]\n",
    "xmax=xg[ncol-1]+dx\n",
    "ymax=yg[nrow-1]+dx\n",
    "afile = open(fileout,\"a\")  # connect to the file; append\n",
    "afile.write(\"\\n SUMMARY IN GRID COORDINATES \")\n",
    "afile.write(\"\\n    (X,Y) OUTLET : \" + repr(float(xout)) + \",\" + repr(float(yout)) )\n",
    "afile.write(\"\\n     (XMIN,YMIN) : \" + repr(float(xmin)) + \",\" + repr(float(ymin)) )\n",
    "afile.write(\"\\n     (XMAX,YMAX) : \" + repr(float(xmax)) + \",\" + repr(float(ymax)))\n",
    "afile.close()\n",
    "\n",
    "########################################################################\n",
    "#### convert particle map into an attribute array (i.e. alive/dead) ####\n",
    "########################################################################\n",
    "np  = 0 # particle count\n",
    "ip  = 0 # particle index\n",
    "lox = 0 # locaton outlet x\n",
    "loy = 0 # location outlet y\n",
    "countP = int(countP)\n",
    "xp   = [0.0  for i in range(countP)] # location x of particle ip\n",
    "yp   = [0.0  for i in range(countP)] # location y of particle ip\n",
    "xps  = [0.0  for i in range(countP)] # start location x of particle ip\n",
    "yps  = [0.0  for i in range(countP)] # start location y of particle ip\n",
    "tp   = [0.0  for i in range(countP)] # location t of particle ip\n",
    "wp   = [0.0  for i in range(countP)] # attribute w of particle ip\n",
    "for irow in range(nrow):\n",
    "    for jcol in range(ncol):\n",
    "        if pbmap[irow][jcol] == 1.0:\n",
    "            xp[ip]=xg[jcol]\n",
    "            yp[ip]=yg[irow]\n",
    "            tp[ip]=0.0\n",
    "            wp[ip]=1.0 # make alive\n",
    "# add start locations to xps,yps for particle ip\n",
    "            xps[ip]=xg[jcol]\n",
    "            yps[ip]=yg[irow]\n",
    "            np += 1\n",
    "            ip += 1\n",
    "        else:\n",
    "            xbg[jcol]= -1e9 # large negative float to indicate boundary\n",
    "            ybg[irow]= -1e9 # large negative float to indicate boundary\n",
    "        if xg[jcol] == xout and yg[irow] == yout : # check if outlet\n",
    "            lop = ip-1\n",
    "            lox = jcol\n",
    "            loy = irow\n",
    "afile = open(fileout,\"a\")  # connect to the file; append\n",
    "afile.write(\"\\n SUMMARY OF PARTICLE ARRAY CALCULATIONS \")\n",
    "afile.write(\"\\n            PARTICLE ARRAY LENGTH : \" + repr(np))\n",
    "afile.write(\"\\n            PARTICLE INPUT COUNT  : \" + repr(countP))\n",
    "afile.write(\"\\n            OUTLET      (LOX,LOY) : \" + repr(float(lox)) + \",\" + repr(float(loy)))\n",
    "afile.write(\"\\n  OUTLET INDEX IN PARTICLE ARRAY  : \" + repr(lop))\n",
    "afile.close()\n",
    "\n",
    "################################\n",
    "### DEBUGGING VERBOSE OUTPUT ###\n",
    "################################\n",
    "if directive == 'VERBOSE':\n",
    "    afile = open(fileout,\"a\")  # connect to the file; append\n",
    "    afile.write(\"\\n PARTICLE START LOCATIONS : \\n IPART XPART YPART \")\n",
    "    cellcount=1\n",
    "    for ip in range(np):\n",
    "        afile.write('\\n ' + repr(ip) + ' ' + repr(round(xp[ip],3)) + ' ' + repr(round(yp[ip],3)))\n",
    "    afile.close()\n",
    "# build a plot of particle positions and outlet position\n",
    "plotfileout = filename.replace(\"mat.dat\",\"000.png\")\n",
    "#    plt.figure()\n",
    "plottitle=\"Initial Particle Positions\"\n",
    "#    plt.scatter(xps, yps, s=1, color='blue')\n",
    "#    plt.scatter(xout, yout, s=100, color='magenta')\n",
    "#    plt.savefig(plotfileout);\n",
    "mappart(plotfileout,plottitle,xps,yps,xout,yout)  \n",
    "\n",
    "#################################\n",
    "#### compute velocity field  ####\n",
    "#################################\n",
    "vx  = [[0.0 for j in range(ncol)] for i in range(nrow)] # 0 lists to store velocity\n",
    "vy  = [[0.0 for j in range(ncol)] for i in range(nrow)] # 0 lists to store velocity\n",
    "cman = float(cman)\n",
    "nman = float(nman)\n",
    "fdeep = float(fdeep)\n",
    "\n",
    "def getdirs(head,vx,vy,nrow,ncol,cman,rman,dx,fdepth,pbmap,dmap,lox,loy,xg,yg):\n",
    "    #########################\n",
    "    #### Some constants  ####\n",
    "    #########################\n",
    "    import math\n",
    "    dxinv=1.0/(dx*3.25) # XY distances in feet\n",
    "    conveyance=(cman/rman)*fdepth**(2./3.)\n",
    "    channel=(cman/rman)*(2.0*fdepth)**(2./3.)\n",
    "    dsqrtiv=1.0/math.sqrt(2.0)\n",
    "    d = [-10.0 for i in range(9)]\n",
    "###################################\n",
    "###         Directions         ####\n",
    "###                            ####\n",
    "###     1       2        3     ####\n",
    "###                            ####\n",
    "###     4       0        5     ####\n",
    "###                            ####\n",
    "###     6       7        8     ####\n",
    "###                            ####\n",
    "###################################    \n",
    "    # interior cells\n",
    "    for irow in range(1,nrow-1):\n",
    "        for jcol in range(1,ncol-1):\n",
    "            d[0]=-1.0\n",
    "            d[1]=(head[irow][jcol]-head[irow-1][jcol-1])*pbmap[irow-1][jcol-1]\n",
    "            d[2]=(head[irow][jcol]-head[irow-1][jcol  ])*pbmap[irow-1][jcol  ]\n",
    "            d[3]=(head[irow][jcol]-head[irow-1][jcol+1])*pbmap[irow-1][jcol+1]\n",
    "            d[4]=(head[irow][jcol]-head[irow  ][jcol-1])*pbmap[irow  ][jcol-1]\n",
    "            d[5]=(head[irow][jcol]-head[irow  ][jcol+1])*pbmap[irow  ][jcol+1]\n",
    "            d[6]=(head[irow][jcol]-head[irow+1][jcol-1])*pbmap[irow+1][jcol-1]\n",
    "            d[7]=(head[irow][jcol]-head[irow+1][jcol  ])*pbmap[irow+1][jcol  ]\n",
    "            d[8]=(head[irow][jcol]-head[irow+1][jcol+1])*pbmap[irow+1][jcol+1]\n",
    "            # check bigger then zero\n",
    "            big = 0\n",
    "            idir = 0\n",
    "            for ii in range(1,9):\n",
    "                if d[ii] > big:\n",
    "                    big = d[ii]\n",
    "                    idir = ii\n",
    "            # assign direction to dmap; if boundary cell ignore\n",
    "            if pbmap[irow][jcol] > 0:\n",
    "                dmap[irow][jcol]=idir*pbmap[irow][jcol]\n",
    "            else:\n",
    "                dmap[irow][jcol]=idir*pbmap[irow][jcol]-10.0\n",
    "            # compute speed and time\n",
    "            if   idir == 1:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[1]*dxinv*dsqrtiv)\n",
    "                vy[irow][jcol]=math.sqrt(2.0)*dx*3.25/vx[irow][jcol]\n",
    "            elif idir == 2:   \n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[2]*dxinv)\n",
    "                vy[irow][jcol]=dx*3.25/vx[irow][jcol]\n",
    "            elif idir == 3:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[3]*dxinv*dsqrtiv)\n",
    "                vy[irow][jcol]=math.sqrt(2.0)*dx*3.25/vx[irow][jcol]\n",
    "            elif idir == 4:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[4]*dxinv)\n",
    "                vy[irow][jcol]=dx*3.25/vx[irow][jcol] \n",
    "            elif idir == 5:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[5]*dxinv)\n",
    "                vy[irow][jcol]=dx*3.25/vx[irow][jcol]  \n",
    "            elif idir == 6:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[6]*dxinv*dsqrtiv)\n",
    "                vy[irow][jcol]=math.sqrt(2.0)*dx*3.25/vx[irow][jcol] \n",
    "            elif idir== 7:\n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[7]*dxinv)\n",
    "                vy[irow][jcol]=dx*3.25/vx[irow][jcol]  \n",
    "            elif idir == 8:  \n",
    "                vx[irow][jcol]=conveyance*math.sqrt(d[8]*dxinv*dsqrtiv)\n",
    "                vy[irow][jcol]=math.sqrt(2.0)*dx*3.25/vx[irow][jcol] \n",
    "            elif idir == 0:\n",
    "# these are sinks or plateaus, route to outlet by cartesian path\n",
    "                vy[irow][jcol]=-2.\n",
    "                vx[irow][jcol]   = head[irow][jcol]-head[loy][lox]\n",
    "                dist=math.sqrt( (xg[jcol]-xg[lox])**2 + (yg[irow]-yg[loy])**2 )\n",
    "                if dist != 0.0:\n",
    "                    vx[irow][jcol]   = conveyance*math.sqrt(vx[irow][jcol]*dxinv*dsqrtiv)\n",
    "                    vy[irow][jcol]   = math.sqrt(2.0)*dist*3.25/vx[irow][jcol] \n",
    "    # if outlet cell override direction \n",
    "    dmap[loy][lox]=0*pbmap[loy][lox]\n",
    "    vx[loy][lox]=0.0\n",
    "    vy[loy][lox]=0.0\n",
    "    return()\n",
    "\n",
    "getdirs(head,vx,vy,nrow,ncol,cman,nman,dx,fdeep,pbmap,dmap,lox,loy,xg,yg)\n",
    "\n",
    "################################\n",
    "### DEBUGGING VERBOSE OUTPUT ###\n",
    "################################\n",
    "if directive == 'VERBOSE' or directive == 'DMAP':\n",
    "    debugfile = filename.replace(\"mat.dat\",\"dbmap.dat\")\n",
    "    afile = open(debugfile,\"w\")  # connect to the file; overwrite\n",
    "# direction code\n",
    "    afile.write(\"DIRECTION MAP : \\n IROW : JCOL :    X(JCOL) :    Y(IROW) : ELEVATION : DIRECTION :   SPEED : PATH-TIME : PBMAP \")\n",
    "    for irow in range(nrow):\n",
    "        for jcol in range(ncol):\n",
    "            afile.write('\\n  %3i :  %3i : %10.3f : %10.3f :   %7.2f :      %4i : %7.2f :   %7.2f : %7.2f ' % (irow,jcol,xg[jcol],yg[irow],\\\n",
    "                        head[irow][jcol],dmap[irow][jcol],vx[irow][jcol],vy[irow][jcol],pbmap[irow][jcol]))\n",
    "            #afile.write('\\n ' + repr(irow) + ' ' + repr(jcol) + ' ' + repr(round(xg[jcol],3)) + ' ' + repr(round(yg[irow],3)) + ' ' \\\n",
    "             #           + repr(round(head[irow][jcol],3)) + ' ' + repr(round(dmap[irow][jcol],3))+ ' ' + repr(round(vx[irow][jcol],3)) \\\n",
    "              #          + ' ' + repr(round(vy[irow][jcol],3)))\n",
    "    afile.close()\n",
    "    \n",
    "##################################################\n",
    "#### regular output static contents completed ####\n",
    "##################################################\n",
    "afile = open(fileout,\"a\")  # connect to the file; append\n",
    "afile.write(\"\\n  VELOCITY MAPS BUILT \")\n",
    "afile.write(\"\\n  PARTICLE MAPS BUILT \")\n",
    "afile.write(\"\\n DIRECTION MAPS BUILT \")\n",
    "\n",
    "maxvx = 0.00000001 # Different floats on purpose to force different memory addresses\n",
    "maxvy =  0.0000001\n",
    "minvx = 10000000.0\n",
    "minvy =  1000000.0\n",
    "for irow in range(nrow):\n",
    "    for jcol in range(ncol):\n",
    "        if vx[irow][jcol] > maxvx:\n",
    "            maxvx = vx[irow][jcol]\n",
    "        if vy[irow][jcol] > maxvy:\n",
    "            maxvy = vy[irow][jcol]\n",
    "        if vx[irow][jcol] < minvx:\n",
    "            minvx = vx[irow][jcol]\n",
    "        if vy[irow][jcol] < minvy:\n",
    "            minvy = vy[irow][jcol]\n",
    "afile.write(\"\\n   MIN VX VALUE = : \" + repr(round(minvx,3)))\n",
    "afile.write(\"\\n   MIN VY VALUE = : \" + repr(round(minvy,3)))\n",
    "afile.write(\"\\n   MAX VX VALUE = : \" + repr(round(maxvx,3)))\n",
    "afile.write(\"\\n   MAX VY VALUE = : \" + repr(round(maxvy,3)))\n",
    "\n",
    "afile.close()\n",
    "\n",
    "def findpart(xp,yp,xg,yg,nrows,ncols,ip):\n",
    "# all arrays must exist, lpx and lpy are returned in call\n",
    "# set search distance\n",
    "    big = 1.0e9\n",
    "# locate nearest grid point\n",
    "    dist1=big\n",
    "    dist2=big\n",
    "    for irow in range(nrows):\n",
    "        for jcol in range(ncols): \n",
    "            dist2 = (xp[ip]-xg[jcol])**2 + (yp[ip]-yg[irow])**2\n",
    "            if dist2 < dist1:\n",
    "                dist1 = dist2\n",
    "                lpx=jcol\n",
    "                lpy=irow\n",
    "    return(lpy,lpx) # should operate on arrays in place\n",
    "\n",
    "def movepart(xp,yp,xg,yg,vx,vy,nrow,ncol,ip,dmap,tp,lox,loy):\n",
    "# function to move a single particle of index ip in the particle attribute array\n",
    "# locate the particle cell index\n",
    "    ploc=findpart(xp,yp,xg,yg,nrow,ncol,ip)\n",
    "    lpx=ploc[1]\n",
    "    lpy=ploc[0]\n",
    "# find direction to move\n",
    "    try: # find direction to move\n",
    "        dmove=int(dmap[lpy][lpx])\n",
    "    except: # raise exception and exit\n",
    "        print(\"FailDMOVE at\",lpy,lpx)\n",
    "#        exit()\n",
    "    ##print(\"dmove\",dmove,lpx,lpy)\n",
    "# find time to move\n",
    "    try: # find time to move\n",
    "        tmove=vy[lpy][lpx]\n",
    "    except: # raise exception and exit\n",
    "        print(\"FailTMOVE at\",lpy,lpx)\n",
    "#        exit()\n",
    "        \n",
    "        flag = 0\n",
    "# move the particle \n",
    "    if dmove == 1: # left up - valid\n",
    "        xp[ip]=xg[lpx-1]\n",
    "        yp[ip]=yg[lpy-1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 2: # up - fixed\n",
    "        xp[ip]=xg[lpx  ]\n",
    "        yp[ip]=yg[lpy-1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 3: # right up - fixed\n",
    "        xp[ip]=xg[lpx+1]\n",
    "        yp[ip]=yg[lpy-1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 4: # left - valid\n",
    "        xp[ip]=xg[lpx-1]\n",
    "        yp[ip]=yg[lpy  ]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 5: # right - fixed\n",
    "        xp[ip]=xg[lpx+1]\n",
    "        yp[ip]=yg[lpy  ]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 6: # left down - valid\n",
    "        xp[ip]=xg[lpx-1]\n",
    "        yp[ip]=yg[lpy+1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 7: # down - fixed\n",
    "        xp[ip]=xg[lpx  ]\n",
    "        yp[ip]=yg[lpy+1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 8: # right down - fixed\n",
    "        xp[ip]=xg[lpx+1]\n",
    "        yp[ip]=yg[lpy+1]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 0: # outlet, sink, or plateau\n",
    "        # check if outlet\n",
    "        if xp[ip]== xg[lox] and yp[ip]==yg[loy]:\n",
    "            tp[ip]=tp[ip]\n",
    "            #print(\"OUTLET\",ip,xp[ip],yp[ip],xg[lox],yg[loy])\n",
    "        else: # must be a sink or plateau -- route to outlet\n",
    "            #print(\"SUMP IN\",ip,xp[ip],yp[ip],xg[lox],yg[loy])\n",
    "            xp[ip]=xg[lox]\n",
    "            yp[ip]=yg[loy]\n",
    "            tp[ip]=tp[ip]+tmove\n",
    "            #print(\"SUMP OUT\",ip,xp[ip],yp[ip],xg[lox],yg[loy])\n",
    "    if dmove == 9: # pit\n",
    "        xp[ip]=xg[lox]\n",
    "        yp[ip]=yg[loy]\n",
    "        tp[ip]=tp[ip]+tmove\n",
    "    if dmove == 10: # boundary\n",
    "        print('ERROR -- ATTEMPTING TO MOVE IN BOUNDARY ARRAY')\n",
    "        print('IP,LPX,LPY   =',ip,lpy,lpx)\n",
    "        print('DMOVE,TMOVE  =',dmove,tmove)\n",
    "    return()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "48\n"
     ]
    }
   ],
   "source": [
    "######################################################\n",
    "#### MOVE ALL CURRENT PARTICLES UNTIL EXIT OR DIE ####\n",
    "######################################################\n",
    "npmv = 0 #number of particles moved\n",
    "#lpx = -1 # initial value lpx\n",
    "#lpy = -2 # initial value lpy\n",
    "alife = float(alife)\n",
    "maxtry = int(0.2*(nrow*ncol)**0.5) # longest path guess.\n",
    "print(maxtry)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "PARTICLES MOVED SO FAR :  0 16\n",
      "PARTICLES MOVED SO FAR :  2000 3\n",
      "PARTICLES MOVED SO FAR :  4000 8\n",
      "PARTICLES MOVED SO FAR :  6000 0\n",
      "PARTICLES MOVED SO FAR :  8000 5\n",
      "PARTICLES MOVED SO FAR :  10000 10\n",
      "PARTICLES MOVED SO FAR :  12000 7\n",
      "PARTICLES MOVED SO FAR :  14000 2\n",
      "PARTICLES MOVED SO FAR :  16000 9\n",
      "PARTICLES MOVED SO FAR :  18000 11\n",
      "PARTICLES MOVED SO FAR :  20000 7\n",
      "PARTICLES MOVED SO FAR :  22000 7\n",
      "PARTICLES MOVED SO FAR :  24000 2\n",
      "PARTICLES MOVED SO FAR :  26000 1\n",
      "PARTICLES MOVED SO FAR :  28000 2\n",
      "PARTICLES MOVED SO FAR :  30000 22\n",
      "PARTICLE COUNT MOVED :  31775\n",
      "MOVE LOOP ENDED\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "for ip in range(np):  # particle index loop\n",
    "    for im in range(maxtry): # maximum steps to traverse area\n",
    "        ploc=findpart(xp,yp,xg,yg,nrow,ncol,ip)\n",
    "        ##print(\"particle loc B4 move: \",ip,xp[ip],yp[ip],tp[ip],ploc[0],ploc[1],dmap[ploc[0]][ploc[1]],head[ploc[0]][ploc[1]],loy,lox)\n",
    "        movepart(xp,yp,xg,yg,vx,vy,nrow,ncol,ip,dmap,tp,lox,loy) # move particle one step\n",
    "        ploc=findpart(xp,yp,xg,yg,nrow,ncol,ip) # locate particle\n",
    "        ##print(\"particle loc AF move: \",ip,xp[ip],yp[ip],tp[ip],ploc[0],ploc[1],dmap[ploc[0]][ploc[1]],head[ploc[0]][ploc[1]],loy,lox)\n",
    "        # check if it made it to outlet\n",
    "        if ploc[0] == loy and ploc[1] == lox:\n",
    "            #print(\"REACH OUTLET : \",ip,ploc[0],ploc[1],loy,lox,im)\n",
    "            break #exit the traverse loop and process next particle\n",
    "        # check for particle death\n",
    "        death = random.random() # generate a random number in range (0,1)\n",
    "        if death > alife:\n",
    "            wp[ip]=0.0 # particle dies\n",
    "            break #exit the traverse loop and process next particle\n",
    "            print('die')\n",
    "    if ip % 2000 == 0:\n",
    "        print(\"PARTICLES MOVED SO FAR : \",ip,im)\n",
    "    npmv += 1 \n",
    "print(\"PARTICLE COUNT MOVED : \",npmv)\n",
    "# build a plot of particle positions and outlet position\n",
    "plotfileout = filename.replace(\"mat.dat\",\"001.png\")\n",
    "#    plt.figure()\n",
    "plottitle=\"Final Particle Positions\"\n",
    "#    plt.scatter(xps, yps, s=1, color='blue')\n",
    "#    plt.scatter(xout, yout, s=100, color='magenta')\n",
    "#    plt.savefig(plotfileout);\n",
    "mappart(plotfileout,plottitle,xp,yp,xout,yout)  \n",
    "print(\"MOVE LOOP ENDED\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6150.942583797583 6150.942583797583 31775.0\n"
     ]
    }
   ],
   "source": [
    "#############################\n",
    "#### sort the time array ####\n",
    "#############################\n",
    "# np=int(countP) ## repair accidental numpy naming\n",
    "sorted_time = sorted(tp)\n",
    "print(max(sorted_time),max(tp),sum(wp))\n",
    "#len(sorted_time)\n",
    "afile = open(fileout,\"a\")  # connect to the file; append\n",
    "afile.write(\"\\n CUMULATIVE ARRIVAL TIME DISTRIBUTION \\n TIME  FRACTION  NUMBER\")\n",
    "gc.collect();  # force garbage collection    #\n",
    "for ip in range(0,np,100):  # particle index loop\n",
    "    # print(ip,sorted_time[ip]/20.0) ## activate to debug\n",
    "    afile.write('\\n  %10.3f  %10.3f  %10i ' % (sorted_time[ip]/20.0,float(ip)/float(np),ip))\n",
    "afile.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit Leinhard Hydrograph\n",
    "# Instructions:\n",
    "# Load the merit function, provide filename from DTRM program.  \n",
    "# Make initial guess using the result() function\n",
    "# Supply to Powell Direction Set method, run until success or failure.  \n",
    "# If success, insert solution into result function and plot.\n",
    "\n",
    "def merit(x): \n",
    "# function to minimize to find values of tbar and shape\n",
    "# x[0] == tbar\n",
    "# x[1] == shape\n",
    "# Script reads sta01234567.out.txt files and plots empirical cumulative and leinhard hydrographs and \n",
    "# systematically finds best values for tbar and shape\n",
    "\n",
    "    filename = 'sta08055700.out.dat' # filename to read\n",
    "\n",
    "    def prMat(amatrix):\n",
    "    # prints the contents of amatrix to stdio\n",
    "        howMany = len(amatrix) # get row count\n",
    "        howWide = len(amatrix[0]) # get column count\n",
    "        for irow in range(howMany):\n",
    "            print(amatrix[irow])\n",
    "        return()\n",
    "\n",
    "################################\n",
    "#   connect and read file      #\n",
    "################################\n",
    "    afile = open(filename,\"r\")  # connect and read file \n",
    "    amatrix = [] # null object to store read\n",
    "    rowNumA = 0\n",
    "    rowRead = 0\n",
    "    substring1=\"ALIVE COUNT\"\n",
    "    for line in afile:\n",
    "        if rowRead < 42: # skip first 42 rows\n",
    "#        print(' Row Read: ',rowRead,' Content: ',line)\n",
    "            rowRead = rowRead+1\n",
    "        elif line.find(substring1) != -1: # check for last row\n",
    "        #print('Last Row')\n",
    "            continue\n",
    "        else: # read the meaningful data\n",
    "            amatrix.append([float(n) for n in line.strip().split()])\n",
    "            rowNumA += 1\n",
    "    afile.close() # Disconnect the file\n",
    "#print(rowNumA); # for debugging activate\n",
    "#prMat(amatrix); # for debugging activate\n",
    "################################\n",
    "#   build lists for plotting   #\n",
    "################################\n",
    "\n",
    "    time = []\n",
    "    acc_flow = []\n",
    "    mod_flow = []\n",
    "    for irow in range(rowNumA):\n",
    "        time.append(amatrix[irow][0])\n",
    "        acc_flow.append(amatrix[irow][1])\n",
    "\n",
    "################################\n",
    "#  Leinhard Hydrograph Kernel  #\n",
    "################################\n",
    "    def kernelfn(tbar,time,scale=2,shape=3,beta=2):\n",
    "        ''' \n",
    "        kernel function for a unit hydrograph - uses a gamma-type hydrograph\n",
    "\n",
    "          scale: a scaling parameter, should be 2, but left adjustable for grins\n",
    "          shape: Nash's reservoir number\n",
    "           tbar: Characteristic time, lag time in NRCS, time-to-peak, \n",
    "                 and time-of-concentration are all similar concepts.\n",
    "           beta: Exponent controling decay rate in exponential part of function; \n",
    "                 Should be a 2 or 3 for typical watersheds, but left adjusible for \n",
    "                 ornery cases.\n",
    "        '''\n",
    "        import math\n",
    "#        term1 = (scale/tbar)/math.gamma(shape)\n",
    " #       term2 = (time)/tbar\n",
    "  #      term3 = term2**(2*shape-1)\n",
    "   #     term4 = math.exp(-1*term2**beta)\n",
    "    #    kernelfn = term1*term3*term4\n",
    "        a5 = time/tbar\n",
    "        a6 = shape/beta\n",
    "        a7 = math.gamma(a6)\n",
    "        a8 = a6**a6\n",
    "        a9 = 1/tbar\n",
    "        a10 = a5**(shape-1)\n",
    "        a11 = math.exp(-a6*(a5**beta))\n",
    "        a12 = a9*a10\n",
    "        a13 = beta/a7\n",
    "        a14 = a13*a12*a11*a8\n",
    "        kernelfn=a14\n",
    "        return kernelfn\n",
    "\n",
    "#########################\n",
    "#  Leinhard Parameters  #\n",
    "#########################\n",
    "    scale = 2 # a scale constant - has units of rate\n",
    "    shape = x[1] # Adjust N value \n",
    "    tbar = x[0] # Adjust t_rms value \n",
    "    beta = 2 # Use beta value (1 or 2) \n",
    "\n",
    "    inc_model = [] # accumulated Leinhard model\n",
    "    for irow in range(rowNumA):\n",
    "        inc_model.append(kernelfn(tbar,time[irow],scale,shape,beta))\n",
    "\n",
    "# Accumulate the values\n",
    "    acc_model = []\n",
    "    acc_model.append(0.0)\n",
    "    for irow in range(1,rowNumA):\n",
    "        acc_model.append( 0.5*(inc_model[irow]+inc_model[irow-1])*(time[irow]-time[irow-1])+acc_model[irow-1] )\n",
    "#    print(inc_model[irow],acc_model[irow])   # activate for debug\n",
    "\n",
    "# Compute the merit function value\n",
    "    sse=0.0\n",
    "    for irow in range(1,rowNumA):\n",
    "        sse=sse+(acc_model[irow]-acc_flow[irow])**2\n",
    "\n",
    "    return(sse)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Optimization terminated successfully.\n",
      "         Current function value: 0.037177\n",
      "         Iterations: 5\n",
      "         Function evaluations: 140\n",
      "[108.92470621   4.32254702]\n"
     ]
    }
   ],
   "source": [
    "import numpy \n",
    "from scipy.optimize import minimize\n",
    "\n",
    "x0 = numpy.array([79.0,1.4])\n",
    "res = minimize(merit, x0, method='powell',options={'disp': True})\n",
    "\n",
    "print(res.x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "def result(x): \n",
    "# function to plot result of optimization - feed the optimization results\n",
    "# x[0] == tbar\n",
    "# x[1] == shape\n",
    "# Script reads sta01234567.out.txt files and plots empirical cumulative and leinhard hydrographs and \n",
    "# systematically finds best values for tbar and shape\n",
    "\n",
    "    filename = 'sta08055700.out.dat' # filename to read\n",
    "\n",
    "    def prMat(amatrix):\n",
    "    # prints the contents of amatrix to stdio\n",
    "        howMany = len(amatrix) # get row count\n",
    "        howWide = len(amatrix[0]) # get column count\n",
    "        for irow in range(howMany):\n",
    "            print(amatrix[irow])\n",
    "        return()\n",
    "\n",
    "\n",
    "    import matplotlib.pyplot as plt  \n",
    "\n",
    "    def Plot2Stairs(list1,list2,list3,list4,ptitle,xlabel,ylabel,legend1,legend2):\n",
    "# Create a line chart of list2,list4 on y axis and list1,list3 on x axis\n",
    "        mydata = plt.figure(figsize = (18,6)) # build a drawing canvass from figure class; aspect ratio 4x3\n",
    "        plt.step(list1, list2, c='red', marker='.',linewidth=2) # basic line plot\n",
    "        plt.step(list3, list4, c='blue', marker='.',linewidth=1) # basic line plot\n",
    "        plt.xlabel(xlabel) # label the x-axis\n",
    "        plt.ylabel(ylabel) # label the y-axis, notice the LaTex markup\n",
    "        plt.legend([legend1,legend2]) # legend for each series\n",
    "        plt.title(ptitle) # make a plot title\n",
    "#    plt.xlim(100000, 120000)\n",
    "#    plt.ylim(2700, 2850)\n",
    "        plt.grid() # display a grid\n",
    "        plt.show() # display the plot\n",
    "        return()\n",
    "################################\n",
    "#   connect and read file      #\n",
    "################################\n",
    "    afile = open(filename,\"r\")  # connect and read file \n",
    "    amatrix = [] # null object to store read\n",
    "    rowNumA = 0\n",
    "    rowRead = 0\n",
    "    substring1=\"ALIVE COUNT\"\n",
    "    for line in afile:\n",
    "        if rowRead < 42: # skip first 42 rows\n",
    "#        print(' Row Read: ',rowRead,' Content: ',line)\n",
    "            rowRead = rowRead+1\n",
    "        elif line.find(substring1) != -1: # check for last row\n",
    "        #print('Last Row')\n",
    "            continue\n",
    "        else: # read the meaningful data\n",
    "            amatrix.append([float(n) for n in line.strip().split()])\n",
    "            rowNumA += 1\n",
    "    afile.close() # Disconnect the file\n",
    "#print(rowNumA); # for debugging activate\n",
    "#prMat(amatrix); # for debugging activate\n",
    "################################\n",
    "#   build lists for plotting   #\n",
    "################################\n",
    "\n",
    "    time = []\n",
    "    acc_flow = []\n",
    "    mod_flow = []\n",
    "    for irow in range(rowNumA):\n",
    "        time.append(amatrix[irow][0])\n",
    "        acc_flow.append(amatrix[irow][1])\n",
    "\n",
    "################################\n",
    "#  Leinhard Hydrograph Kernel  #\n",
    "################################\n",
    "    def kernelfn(tbar,time,scale=2,shape=3,beta=2):\n",
    "        ''' \n",
    "        kernel function for a unit hydrograph - uses a gamma-type hydrograph\n",
    "\n",
    "          scale: a scaling parameter, should be 2, but left adjustable for grins\n",
    "          shape: Nash's reservoir number\n",
    "           tbar: Characteristic time, lag time in NRCS, time-to-peak, \n",
    "                 and time-of-concentration are all similar concepts.\n",
    "           beta: Exponent controling decay rate in exponential part of function; \n",
    "                 Should be a 2 or 3 for typical watersheds, but left adjusible for \n",
    "                 ornery cases.\n",
    "        '''\n",
    "        import math\n",
    "#        term1 = (scale/tbar)/math.gamma(shape)\n",
    " #       term2 = (time)/tbar\n",
    "  #      term3 = term2**(2*shape-1)\n",
    "   #     term4 = math.exp(-1*term2**beta)\n",
    "    #    kernelfn = term1*term3*term4\n",
    "        a5 = time/tbar\n",
    "        a6 = shape/beta\n",
    "        a7 = math.gamma(a6)\n",
    "        a8 = a6**a6\n",
    "        a9 = 1/tbar\n",
    "        a10 = a5**(shape-1)\n",
    "        a11 = math.exp(-a6*(a5**beta))\n",
    "        a12 = a9*a10\n",
    "        a13 = beta/a7\n",
    "        a14 = a13*a12*a11*a8\n",
    "        kernelfn=a14\n",
    "        return kernelfn\n",
    "\n",
    "#########################\n",
    "#  Leinhard Parameters  #\n",
    "#########################\n",
    "    scale = 2 # a scale constant - has units of rate\n",
    "    shape = x[1] # Adjust N value \n",
    "    tbar = x[0] # Adjust t_rms value \n",
    "    beta = 2 # Use beta value (1 or 2) \n",
    "\n",
    "    inc_model = [] # accumulated Leinhard model\n",
    "    for irow in range(rowNumA):\n",
    "        inc_model.append(kernelfn(tbar,time[irow],scale,shape,beta))\n",
    "\n",
    "# Accumulate the values\n",
    "    acc_model = []\n",
    "    acc_model.append(0.0)\n",
    "    for irow in range(1,rowNumA):\n",
    "        acc_model.append( 0.5*(inc_model[irow]+inc_model[irow-1])*(time[irow]-time[irow-1])+acc_model[irow-1] )\n",
    "#    print(inc_model[irow],acc_model[irow])   # activate for debug\n",
    "\n",
    "# Compute the merit function value\n",
    "    sse=0.0\n",
    "    for irow in range(1,rowNumA):\n",
    "        sse=sse+(acc_model[irow]-acc_flow[irow])**2\n",
    "\n",
    "    ptitle=\"DTRM Analysis for \" + filename + \\\n",
    "    \"\\n Leinhard Parameters : \" + \\\n",
    "    \"\\n t_rms : \" + repr(round(tbar,3)) + \\\n",
    "    \"\\n N : \" + repr(round(shape,3)) + \\\n",
    "    \"\\n Beta : \"+ repr(beta) + \\\n",
    "    \"\\n SSE : \" + repr(round(sse,6))\n",
    "    xlabel=\"Time (minutes)\"\n",
    "    ylabel=\"Washout Fraction\"\n",
    "    legend1=\"DTRM Time-Area\"\n",
    "    legend2=\"Fitted Leinhard Time-Area\"\n",
    "\n",
    "    Plot2Stairs(time,acc_flow,time,acc_model,ptitle,xlabel,ylabel,legend1,legend2);\n",
    "    return(sse);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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4PKECAYG0nKp6+8ODBX19fVMmDBh8WPOnDlsXy6yO2fOHH75y18uPvaOO+7gyiuv7PU1Ghsb6bjMaFfbq7ntttv49Kc/3eUxc+bMYfPNl1oddbmMGTOm3fNnn3128Xv1pje9iXXXXXfx81tuuaXbPi6PY445hnXXXZfW1taaXUOSJGkgaG6Gb32r+LPj9kmT4KSTij+bm5eECyeemGy/PUS0f2y/PcxvHQ0E9bTw/ziBJBY/bqaBlXmFelqqhgttwcLX+TLX1b2Phv+3N2S2f9x8Mw0r/50T6k+jYaW/FgFBVxoa4IQTeh8i9PYcScvNyoc+svLKK3PHHXe023bzzTcDxYf5X/3qVxx66KFAET7cdttt7LHHHiu6m0ycOJGJE6suu9pnFi5cyIgRXf/TWnPNNRe/XyeffDJjxozhuOOOW7x/m222qUnfWltbufTSS1l//fX54x//yK677rrUMT3pvyRJ0kDTsWqhp3MszJ9fBAuFzudbWKpyYeqmMDMX7+92GERPhjys6MkTJa0ww7byobMUuC+1fdt//PHH09zczIQJE/j2t7/Nl7/8ZX7xi18wYcIEfvGLX/Dyyy9zyCGHsM0227DVVltx+eWXAzB//nw++tGPsummm7LffvsxvxcLEnfWZlNTEx/4wAeA4kP/IYccQmNjI29961s5/fTTF5+/aNEiDjvsMMaNG8f73ve+xdc+++yzede73sWWW27J/vvvzyuvvALAwQcfzNSpU9l2222ZPn06//znP2loaGD8+PF86Utf6tX71rGPBx10EDvttBMbbLABv/71r5k+fTrjx49n9913p6WlBYDbb7+dXXbZha233prddtuNJ598stO2x40bx7Rp07jwwgsXbz/55JM58MAD2WGHHTjwwAN5+umn2X///XnXu97Fu971Lm666SYAbrnlFhoaGthqq63YfvvteeCBB3r12iRJkpZHd5UMJ57I4qqF7bdfEjx0rFSorFJYmVe4mYalKxembtquKqHh5u9x3ag9+HqczHWj9qBh8sbtO1EOgzjhm2NoaKoyDKItWPj614s/OwsWrEyQhqRh+fVu2/85v/ZaEbp29f99PTV//nwmTJgAwEYbbcSll166eN8pp5zCKaecwlVXXQXA2muvzW233cYZZ5wBwIknnsi73/1uzjnnHF544QW22WYb3vOe9/DjH/+YVVZZ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\n",
      "text/plain": [
       "<Figure size 1296x432 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "0.044126807636904235"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "result([res.x[0] , res.x[1]])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
